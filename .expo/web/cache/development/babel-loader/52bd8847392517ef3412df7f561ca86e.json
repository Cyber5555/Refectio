{"ast":null,"code":"import * as React from 'react';\nimport formatWithMask from \"./formatWithMask\";\nexport default (function (props) {\n  var value = props.value,\n      mask = props.mask,\n      onChangeText = props.onChangeText,\n      _props$placeholderFil = props.placeholderFillCharacter,\n      placeholderFillCharacter = _props$placeholderFil === void 0 ? '_' : _props$placeholderFil,\n      obfuscationCharacter = props.obfuscationCharacter,\n      showObfuscatedValue = props.showObfuscatedValue;\n  var maskArray = React.useMemo(function () {\n    return typeof mask === 'function' ? mask(value) : mask;\n  }, [mask, value]);\n  var formattedValueResult = React.useMemo(function () {\n    return formatWithMask({\n      text: value || '',\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n  }, [mask, obfuscationCharacter, value]);\n  var maskHasObfuscation = React.useMemo(function () {\n    return maskArray && !!maskArray.find(function (maskItem) {\n      return Array.isArray(maskItem);\n    });\n  }, [maskArray]);\n  var isValueObfuscated = React.useMemo(function () {\n    return !!maskHasObfuscation && !!showObfuscatedValue;\n  }, [maskHasObfuscation, showObfuscatedValue]);\n  var handleChangeText = React.useCallback(function (text) {\n    var textToFormat = text;\n\n    if (isValueObfuscated) {\n      textToFormat = formattedValueResult.masked || '';\n\n      if (textToFormat.length > text.length) {\n        textToFormat = textToFormat.slice(0, -1);\n      } else if (textToFormat.length < text.length) {\n        textToFormat = textToFormat + text[text.length - 1];\n      }\n    }\n\n    var result = formatWithMask({\n      text: textToFormat,\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n    onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n  }, [isValueObfuscated, mask, obfuscationCharacter, onChangeText, formattedValueResult.masked]);\n  var defaultPlaceholder = React.useMemo(function () {\n    if (maskArray) {\n      return maskArray.map(function (maskChar) {\n        if (typeof maskChar === 'string') {\n          return maskChar;\n        } else {\n          return placeholderFillCharacter;\n        }\n      }).join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n  var inputValue = isValueObfuscated ? formattedValueResult.obfuscated : formattedValueResult.masked;\n  return {\n    onChangeText: handleChangeText,\n    value: inputValue,\n    selection: isValueObfuscated ? {\n      start: inputValue.length,\n      end: inputValue.length\n    } : undefined,\n    placeholder: defaultPlaceholder\n  };\n});","map":{"version":3,"mappings":"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","names":["React","formatWithMask","props","value","mask","onChangeText","placeholderFillCharacter","obfuscationCharacter","showObfuscatedValue","maskArray","useMemo","formattedValueResult","text","maskHasObfuscation","find","maskItem","Array","isArray","isValueObfuscated","handleChangeText","useCallback","textToFormat","masked","length","slice","result","unmasked","obfuscated","defaultPlaceholder","map","maskChar","join","undefined","inputValue","selection","start","end","placeholder"],"sources":["useMaskedInputProps.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport formatWithMask from './formatWithMask';\nimport type { Mask } from './formatWithMask.types';\n\ntype UseMaskedInputProps = {\n  value: string;\n  mask?: Mask;\n  onChangeText?(masked: string, unmasked: string, obfuscated: string): void;\n  showObfuscatedValue?: boolean;\n  placeholderFillCharacter?: string;\n  obfuscationCharacter?: string;\n};\n\nexport default (props: UseMaskedInputProps) => {\n  const {\n    value,\n    mask,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return {\n    onChangeText: handleChangeText,\n    value: inputValue,\n    selection: isValueObfuscated\n      ? { start: inputValue.length, end: inputValue.length }\n      : undefined,\n    placeholder: defaultPlaceholder,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}