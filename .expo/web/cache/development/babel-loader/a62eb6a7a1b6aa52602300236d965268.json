{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"mask\", \"value\", \"onChangeText\", \"placeholderFillCharacter\", \"obfuscationCharacter\", \"showObfuscatedValue\", \"selection\"];\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nimport * as React from 'react';\nimport TextInput from \"react-native-web/dist/exports/TextInput\";\nimport formatWithMask from \"./formatWithMask\";\nexport default React.forwardRef(function (props, ref) {\n  var mask = props.mask,\n      value = props.value,\n      onChangeText = props.onChangeText,\n      _props$placeholderFil = props.placeholderFillCharacter,\n      placeholderFillCharacter = _props$placeholderFil === void 0 ? '_' : _props$placeholderFil,\n      obfuscationCharacter = props.obfuscationCharacter,\n      showObfuscatedValue = props.showObfuscatedValue,\n      selection = props.selection,\n      rest = _objectWithoutProperties(props, _excluded);\n\n  var maskArray = React.useMemo(function () {\n    return typeof mask === 'function' ? mask(value) : mask;\n  }, [mask, value]);\n  var formattedValueResult = React.useMemo(function () {\n    return formatWithMask({\n      text: value || '',\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n  }, [mask, obfuscationCharacter, value]);\n  var maskHasObfuscation = React.useMemo(function () {\n    return maskArray && !!maskArray.find(function (maskItem) {\n      return Array.isArray(maskItem);\n    });\n  }, [maskArray]);\n  var isValueObfuscated = React.useMemo(function () {\n    return !!maskHasObfuscation && !!showObfuscatedValue;\n  }, [maskHasObfuscation, showObfuscatedValue]);\n  var handleChangeText = React.useCallback(function (text) {\n    var textToFormat = text;\n\n    if (isValueObfuscated) {\n      textToFormat = formattedValueResult.masked || '';\n\n      if (textToFormat.length > text.length) {\n        textToFormat = textToFormat.slice(0, -1);\n      } else if (textToFormat.length < text.length) {\n        textToFormat = textToFormat + text[text.length - 1];\n      }\n    }\n\n    var result = formatWithMask({\n      text: textToFormat,\n      mask: mask,\n      obfuscationCharacter: obfuscationCharacter\n    });\n    onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n  }, [isValueObfuscated, mask, obfuscationCharacter, onChangeText, formattedValueResult.masked]);\n  var defaultPlaceholder = React.useMemo(function () {\n    if (maskArray) {\n      return maskArray.map(function (maskChar) {\n        if (typeof maskChar === 'string') {\n          return maskChar;\n        } else {\n          return placeholderFillCharacter;\n        }\n      }).join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n  var inputValue = isValueObfuscated ? formattedValueResult.obfuscated : formattedValueResult.masked;\n  return React.createElement(TextInput, _extends({\n    placeholder: defaultPlaceholder\n  }, rest, {\n    value: inputValue,\n    selection: isValueObfuscated ? {\n      start: inputValue.length,\n      end: inputValue.length\n    } : selection,\n    onChangeText: handleChangeText,\n    ref: ref\n  }));\n});","map":{"version":3,"mappings":"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","names":["React","formatWithMask","forwardRef","props","ref","mask","value","onChangeText","placeholderFillCharacter","obfuscationCharacter","showObfuscatedValue","selection","rest","maskArray","useMemo","formattedValueResult","text","maskHasObfuscation","find","maskItem","Array","isArray","isValueObfuscated","handleChangeText","useCallback","textToFormat","masked","length","slice","result","unmasked","obfuscated","defaultPlaceholder","map","maskChar","join","undefined","inputValue","TextInput","placeholder","start","end"],"sources":["MaskInput.tsx"],"sourcesContent":["import * as React from 'react';\nimport { TextInput } from 'react-native';\n\nimport type { MaskInputProps } from './MaskInput.types';\nimport formatWithMask from './formatWithMask';\n\nexport default React.forwardRef(function (\n  props: MaskInputProps,\n  ref: React.Ref<TextInput>\n) {\n  const {\n    mask,\n    value,\n    onChangeText,\n    placeholderFillCharacter = '_',\n    obfuscationCharacter,\n    showObfuscatedValue,\n    selection,\n    ...rest\n  } = props;\n\n  const maskArray = React.useMemo(\n    () => (typeof mask === 'function' ? mask(value) : mask),\n    [mask, value]\n  );\n\n  const formattedValueResult = React.useMemo(() => {\n    return formatWithMask({ text: value || '', mask, obfuscationCharacter });\n  }, [mask, obfuscationCharacter, value]);\n\n  const maskHasObfuscation = React.useMemo(\n    () => maskArray && !!maskArray.find((maskItem) => Array.isArray(maskItem)),\n    [maskArray]\n  );\n\n  const isValueObfuscated = React.useMemo(\n    () => !!maskHasObfuscation && !!showObfuscatedValue,\n    [maskHasObfuscation, showObfuscatedValue]\n  );\n\n  const handleChangeText = React.useCallback(\n    (text: string) => {\n      let textToFormat = text;\n\n      if (isValueObfuscated) {\n        textToFormat = formattedValueResult.masked || '';\n\n        if (textToFormat.length > text.length) {\n          textToFormat = textToFormat.slice(0, -1);\n        } else if (textToFormat.length < text.length) {\n          textToFormat = textToFormat + text[text.length - 1];\n        }\n      }\n\n      const result = formatWithMask({ text: textToFormat, mask, obfuscationCharacter });\n\n      onChangeText && onChangeText(result.masked, result.unmasked, result.obfuscated);\n    },\n    [\n      isValueObfuscated,\n      mask,\n      obfuscationCharacter,\n      onChangeText,\n      formattedValueResult.masked,\n    ]\n  );\n\n  const defaultPlaceholder = React.useMemo(() => {\n    if (maskArray) {\n      return maskArray\n        .map((maskChar) => {\n          if (typeof maskChar === 'string') {\n            return maskChar;\n          } else {\n            return placeholderFillCharacter;\n          }\n        })\n        .join('');\n    } else {\n      return undefined;\n    }\n  }, [maskArray, placeholderFillCharacter]);\n\n  const inputValue = isValueObfuscated\n    ? formattedValueResult.obfuscated\n    : formattedValueResult.masked;\n\n  return (\n    <TextInput\n      placeholder={defaultPlaceholder}\n      {...rest}\n      value={inputValue}\n      selection={\n        isValueObfuscated\n          ? { start: inputValue.length, end: inputValue.length }\n          : selection\n      }\n      onChangeText={handleChangeText}\n      ref={ref}\n    />\n  );\n});\n"]},"metadata":{},"sourceType":"module"}