{"ast":null,"code":"export default function formatWithMask(props) {\n  var text = props.text,\n      mask = props.mask,\n      _props$obfuscationCha = props.obfuscationCharacter,\n      obfuscationCharacter = _props$obfuscationCha === void 0 ? '*' : _props$obfuscationCha;\n  if (!text) return {\n    masked: '',\n    unmasked: '',\n    obfuscated: ''\n  };\n  if (!mask) return {\n    masked: text || '',\n    unmasked: text || '',\n    obfuscated: text || ''\n  };\n  var maskArray = typeof mask === 'function' ? mask(text) : mask;\n  var masked = '';\n  var obfuscated = '';\n  var unmasked = '';\n  var maskCharIndex = 0;\n  var valueCharIndex = 0;\n\n  while (true) {\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    if (valueCharIndex === text.length) {\n      break;\n    }\n\n    var maskChar = maskArray[maskCharIndex];\n    var valueChar = text[valueCharIndex];\n\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    var unmaskedValueChar = text[valueCharIndex];\n\n    if (typeof maskChar === 'object') {\n      valueCharIndex += 1;\n      var shouldObsfucateChar = Array.isArray(maskChar);\n      var maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n      var matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      masked += maskChar;\n      obfuscated += maskChar;\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return {\n    masked: masked,\n    unmasked: unmasked,\n    obfuscated: obfuscated\n  };\n}","map":{"version":3,"mappings":"AAEA,eAAe,SAASA,cAAT,CACbC,KADa,EAES;EACtB,IAAQC,IAAR,GAAmDD,KAAnD,CAAQC,IAAR;EAAA,IAAcC,IAAd,GAAmDF,KAAnD,CAAcE,IAAd;EAAA,4BAAmDF,KAAnD,CAAoBG,oBAApB;EAAA,IAAoBA,oBAApB,sCAA2C,GAA3C;EAGA,IAAI,CAACF,IAAL,EAAW,OAAO;IAAEG,MAAM,EAAE,EAAV;IAAcC,QAAQ,EAAE,EAAxB;IAA4BC,UAAU,EAAE;EAAxC,CAAP;EACX,IAAI,CAACJ,IAAL,EACE,OAAO;IACLE,MAAM,EAAEH,IAAI,IAAI,EADX;IAELI,QAAQ,EAAEJ,IAAI,IAAI,EAFb;IAGLK,UAAU,EAAEL,IAAI,IAAI;EAHf,CAAP;EAMF,IAAIM,SAAS,GAAG,OAAOL,IAAP,KAAgB,UAAhB,GAA6BA,IAAI,CAACD,IAAD,CAAjC,GAA0CC,IAA1D;EAEA,IAAIE,MAAM,GAAG,EAAb;EACA,IAAIE,UAAU,GAAG,EAAjB;EACA,IAAID,QAAQ,GAAG,EAAf;EAEA,IAAIG,aAAa,GAAG,CAApB;EACA,IAAIC,cAAc,GAAG,CAArB;;EAEA,OAAO,IAAP,EAAa;IAEX,IAAID,aAAa,KAAKD,SAAS,CAACG,MAAhC,EAAwC;MACtC;IAHS;;IAOX,IAAID,cAAc,KAAKR,IAAI,CAACS,MAA5B,EAAoC;MAClC;IACD;;IAED,IAAIC,QAAQ,GAAGJ,SAAS,CAACC,aAAD,CAAxB;IACA,IAAII,SAAS,GAAGX,IAAI,CAACQ,cAAD,CAApB;;IAGA,IAAIE,QAAQ,KAAKC,SAAjB,EAA4B;MAC1BR,MAAM,IAAIO,QAAVP;MACAE,UAAU,IAAIK,QAAdL;MAEAG,cAAc,IAAI,CAAlBA;MACAD,aAAa,IAAI,CAAjBA;MACA;IACD;;IAED,IAAIK,iBAAiB,GAAGZ,IAAI,CAACQ,cAAD,CAA5B;;IAGA,IAAI,OAAOE,QAAP,KAAoB,QAAxB,EAAkC;MAEhCF,cAAc,IAAI,CAAlBA;MAEA,IAAMK,mBAAmB,GAAGC,KAAK,CAACC,OAAND,CAAcJ,QAAdI,CAA5B;MAEA,IAAME,aAAa,GAAGF,KAAK,CAACC,OAAND,CAAcJ,QAAdI,IAA0BJ,QAAQ,CAAC,CAAD,CAAlCI,GAAwCJ,QAA9D;MAEA,IAAMO,UAAU,GAAGC,MAAM,CAACF,aAAD,CAANE,CAAsBC,IAAtBD,CAA2BP,SAA3BO,CAAnB;;MAGA,IAAID,UAAJ,EAAgB;QACdd,MAAM,IAAIQ,SAAVR;QACAE,UAAU,IAAIQ,mBAAmB,GAAGX,oBAAH,GAA0BS,SAA3DN;QACAD,QAAQ,IAAIQ,iBAAZR;QAEAG,aAAa,IAAI,CAAjBA;MACD;;MAED;IAnBF,OAoBO;MAELJ,MAAM,IAAIO,QAAVP;MACAE,UAAU,IAAIK,QAAdL;MAEAE,aAAa,IAAI,CAAjBA;MACA;IACD;EACF;;EAED,OAAO;IAAEJ,MAAF,EAAEA,MAAF;IAAUC,QAAV,EAAUA,QAAV;IAAoBC;EAApB,CAAP;AACD","names":["formatWithMask","props","text","mask","obfuscationCharacter","masked","unmasked","obfuscated","maskArray","maskCharIndex","valueCharIndex","length","maskChar","valueChar","unmaskedValueChar","shouldObsfucateChar","Array","isArray","maskCharRegex","matchRegex","RegExp","test"],"sources":["formatWithMask.ts"],"sourcesContent":["import type { FormatWithMaskProps, FormatWithMaskResult } from './formatWithMask.types';\n\nexport default function formatWithMask(\n  props: FormatWithMaskProps\n): FormatWithMaskResult {\n  const { text, mask, obfuscationCharacter = '*' } = props;\n\n  // make sure it'll not break with null or undefined inputs\n  if (!text) return { masked: '', unmasked: '', obfuscated: '' };\n  if (!mask)\n    return {\n      masked: text || '',\n      unmasked: text || '',\n      obfuscated: text || '',\n    };\n\n  let maskArray = typeof mask === 'function' ? mask(text) : mask;\n\n  let masked = '';\n  let obfuscated = '';\n  let unmasked = '';\n\n  let maskCharIndex = 0;\n  let valueCharIndex = 0;\n\n  while (true) {\n    // if mask is ended, break.\n    if (maskCharIndex === maskArray.length) {\n      break;\n    }\n\n    // if value is ended, break.\n    if (valueCharIndex === text.length) {\n      break;\n    }\n\n    let maskChar = maskArray[maskCharIndex];\n    let valueChar = text[valueCharIndex];\n\n    // value equals mask: add to masked result and advance on both mask and value indexes\n    if (maskChar === valueChar) {\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      valueCharIndex += 1;\n      maskCharIndex += 1;\n      continue;\n    }\n\n    let unmaskedValueChar = text[valueCharIndex];\n\n    // it's a regex maskChar: let's advance on value index and validate the value within the regex\n    if (typeof maskChar === 'object') {\n      // advance on value index\n      valueCharIndex += 1;\n\n      const shouldObsfucateChar = Array.isArray(maskChar);\n\n      const maskCharRegex = Array.isArray(maskChar) ? maskChar[0] : maskChar;\n\n      const matchRegex = RegExp(maskCharRegex).test(valueChar);\n\n      // value match regex: add to masked and unmasked result and advance on mask index too\n      if (matchRegex) {\n        masked += valueChar;\n        obfuscated += shouldObsfucateChar ? obfuscationCharacter : valueChar;\n        unmasked += unmaskedValueChar;\n\n        maskCharIndex += 1;\n      }\n\n      continue;\n    } else {\n      // it's a fixed maskChar: add to maskedResult and advance on mask index\n      masked += maskChar;\n      obfuscated += maskChar;\n\n      maskCharIndex += 1;\n      continue;\n    }\n  }\n\n  return { masked, unmasked, obfuscated };\n}\n"]},"metadata":{},"sourceType":"module"}